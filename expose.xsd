<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="wiki.xsl"?>
<xsd:schema
    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
    xmlns="http://www.w3.org/1999/xhtml"
    xmlns:html="http://www.w3.org/1999/xhtml">
  <xsd:annotation>
    <xsd:documentation>
      Example:
      <pre><![CDATA[
      <?xml version="1.0"?>
      <module name="modulename" include="vector">
        <doc>module doc string</doc>

        <class name="DVector" type="std::vector&lt;double&gt;">
          <doc>class doc string</doc>
          <init/>
          <property name="size" get="size" set="resize"/>
          <def func="push_back"/>
        </class>
      </module>
      ]]></pre>
    </xsd:documentation>
  </xsd:annotation>

  <xsd:simpleType name="ident">
    <xsd:restriction base="xsd:string">
      <xsd:pattern value="[a-zA-Z_][a-zA-Z0-9_]*"/>
    </xsd:restriction>
  </xsd:simpleType>


  <xsd:simpleType name="retsemantictype">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="default"/>
      <xsd:enumeration value="copy"/>
      <xsd:enumeration value="managedref"/>
      <xsd:enumeration value="self"/>
    </xsd:restriction>
  </xsd:simpleType>


  <xsd:simpleType name="symbol">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>


  <xsd:simpleType name="arglist">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>

  <xsd:simpleType name="includelist">
    <xsd:restriction base="xsd:string"/>
  </xsd:simpleType>


  <xsd:element name="module">
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element ref="def"/>
        <xsd:element ref="class"/>
        <xsd:element ref="doc"/>
      </xsd:choice>
      <xsd:attribute name="name" type="ident" use="required">
        <xsd:annotation>
          <xsd:documentation>
            The name of the module. This will be the name by which the module is
            imported.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
      <xsd:attribute name="include" type="includelist" use="required">
        <xsd:annotation>
          <xsd:documentation>
            A comma seperated list of include files to scan for the types and
            functions to expose.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>


  <xsd:element name="def">
    <xsd:annotation>
      <xsd:documentation>
        <p>Specifies a method when inside &lt;class&gt;, specifies a function
        when inside &lt;module&gt;.</p>

        <p>Special methods can be defined by using the equivalent Python method
        name:</p>
        <table>
          <tr><th>Python</th><th>C++</th></tr>
          <tr><td>__new__</td><td>tp_new</td></tr>
          <tr><td>__repr__</td><td>tp_repr</td></tr>
          <tr><td>__str__</td><td>tp_str</td></tr>
          <tr><td>__lt__</td><td>tp_richcompare</td></tr>
          <tr><td>__le__</td><td>tp_richcompare</td></tr>
          <tr><td>__eq__</td><td>tp_richcompare</td></tr>
          <tr><td>__ne__</td><td>tp_richcompare</td></tr>
          <tr><td>__gt__</td><td>tp_richcompare</td></tr>
          <tr><td>__ge__</td><td>tp_richcompare</td></tr>
          <tr><td>__cmp__</td><td>tp_compare</td></tr>
          <tr><td>__hash__</td><td>tp_hash</td></tr>
          <tr><td>__nonzero__</td><td>tp_as_number->nb_nonzero</td></tr>
          <tr><td>__getattr__</td><td>tp_getattro</td></tr>
          <tr><td>__setattr__</td><td>tp_setattro</td></tr>
          <tr><td>__get__</td><td>tp_descr_get</td></tr>
          <tr><td>__set__</td><td>tp_descr_set</td></tr>
          <tr><td>__call__</td><td>tp_call</td></tr>
          <tr><td>__iter__</td><td>tp_iter</td></tr>
          <tr><td>next</td><td>tp_iternext</td></tr>
          <tr><td>__contains__</td><td>tp_as_sequence->sq_contains</td></tr>
          <tr><td>__add__</td><td>tp_as_number->nb_add</td></tr>
          <tr><td>__radd__</td><td>tp_as_number->nb_add (arguments reversed)</td></tr>
          <tr><td>__sub__</td><td>tp_as_number->nb_subtract</td></tr>
          <tr><td>__rsub__</td><td>tp_as_number->nb_subtract (arguments reversed)</td></tr>
          <tr><td>__mul__</td><td>tp_as_number->nb_multiply</td></tr>
          <tr><td>__rmul__</td><td>tp_as_number->nb_multiply (arguments reversed)</td></tr>
          <tr><td>__floordiv__</td><td>tp_as_number->nb_floor_divide</td></tr>
          <tr><td>__rfloordiv__</td><td>tp_as_number->nb_floor_divide (arguments reversed)</td></tr>
          <tr><td>__mod__</td><td>tp_as_number->nb_remainder</td></tr>
          <tr><td>__rmod__</td><td>tp_as_number->nb_remainder (arguments reversed)</td></tr>
          <tr><td>__divmod__</td><td>tp_as_number->nb_divmod</td></tr>
          <tr><td>__rdivmod__</td><td>tp_as_number->nb_divmod (arguments reversed)</td></tr>
          <tr><td>__pow__</td><td>tp_as_number->nb_power</td></tr>
          <tr><td>__rpow__</td><td>tp_as_number->nb_power (arguments reversed)</td></tr>
          <tr><td>__lshift__</td><td>tp_as_number->nb_lshift</td></tr>
          <tr><td>__rlshift__</td><td>tp_as_number->nb_lshift (arguments reversed)</td></tr>
          <tr><td>__rshift__</td><td>tp_as_number->nb_rshift</td></tr>
          <tr><td>__rrshift__</td><td>tp_as_number->nb_rshift (arguments reversed)</td></tr>
          <tr><td>__and__</td><td>tp_as_number->nb_and</td></tr>
          <tr><td>__rand__</td><td>tp_as_number->nb_and (arguments reversed)</td></tr>
          <tr><td>__xor__</td><td>tp_as_number->nb_xor</td></tr>
          <tr><td>__rxor__</td><td>tp_as_number->nb_xor (arguments reversed)</td></tr>
          <tr><td>__or__</td><td>tp_as_number->nb_or</td></tr>
          <tr><td>__ror__</td><td>tp_as_number->nb_or (arguments reversed)</td></tr>
          <tr><td>__div__</td><td>tp_as_number->nb_divide</td></tr>
          <tr><td>__rdiv__</td><td>tp_as_number->nb_divide (arguments reversed)</td></tr>
          <tr><td>__truediv__</td><td>tp_as_number->nb_true_divide</td></tr>
          <tr><td>__rtruediv__</td><td>tp_as_number->nb_true_divide (arguments reversed)</td></tr>
          <tr><td>__iadd__</td><td>tp_as_number->nb_inplace_add</td></tr>
          <tr><td>__isub__</td><td>tp_as_number->nb_inplace_subtract</td></tr>
          <tr><td>__imul__</td><td>tp_as_number->nb_inplace_multiply</td></tr>
          <tr><td>__idiv__</td><td>tp_as_number->nb_inplace_divide</td></tr>
          <tr><td>__itruediv__</td><td>tp_as_number->nb_inplace_true_divide</td></tr>
          <tr><td>__ifloordiv__</td><td>tp_as_number->nb_inplace_floor_divide</td></tr>
          <tr><td>__imod__</td><td>tp_as_number->nb_inplace_remainder</td></tr>
          <tr><td>__ipow__</td><td>tp_as_number->nb_inplace_power</td></tr>
          <tr><td>__ilshift__</td><td>tp_as_number->nb_inplace_lshift</td></tr>
          <tr><td>__irshift__</td><td>tp_as_number->nb_inplace_rshift</td></tr>
          <tr><td>__iand__</td><td>tp_as_number->nb_inplace_and</td></tr>
          <tr><td>__ixor__</td><td>tp_as_number->nb_inplace_xor</td></tr>
          <tr><td>__ior__</td><td>tp_as_number->nb_inplace_or</td></tr>
          <tr><td>__neg__</td><td>tp_as_number->nb_negative</td></tr>
          <tr><td>__pos__</td><td>tp_as_number->nb_positive</td></tr>
          <tr><td>__abs__</td><td>tp_as_number->nb_absolute</td></tr>
          <tr><td>__invert__</td><td>tp_as_number->nb_invert</td></tr>
          <tr><td>__int__</td><td>tp_as_number->nb_int</td></tr>
          <tr><td>__long__</td><td>tp_as_number->nb_long</td></tr>
          <tr><td>__float__</td><td>tp_as_number->nb_float</td></tr>
          <tr><td>__oct__</td><td>tp_as_number->nb_oct</td></tr>
          <tr><td>__hex__</td><td>tp_as_number->nb_hex</td></tr>
          <tr><td>__index__</td><td>tp_as_number->nb_index</td></tr>
          <tr><td>__coerce__</td><td>tp_as_number->nb_coerce</td></tr>
        </table>

        <p>The following two cannot be used because they correspond to the
        constructor and destructor. To specify the constructor, use
        the &lt;init&gt; tag.</p>
        <table>
          <tr><th>Python</th><th>C++</th></tr>
          <tr><td>__init__</td><td>tp_init</td></tr>
          <tr><td>__del__</td><td>tp_dealloc</td></tr>
        </table>

        <p>For functions that dont have a distinct equivalent in Python, the
        following names are provided:</p>
        <table>
          <tr><th>Name</th><th>C++</th></tr>
          <tr><td>__concat__</td><td>tp_as_sequence->sq_concat</td></tr>
          <tr><td>__iconcat__</td><td>tp_as_sequence->sq_inplace_concat</td></tr>
          <tr><td>__repeat__</td><td>tp_as_sequence->sq_repeat</td></tr>
          <tr><td>__irepeat__</td><td>tp_as_sequence->sq_inplace_repeat</td></tr>
          <tr><td>__mapping__len__</td><td>tp_as_mapping->mp_length</td></tr>
          <tr><td>__sequence__len__</td><td>tp_as_sequence->sq_length</td></tr>
          <tr><td>__mapping__getitem__</td><td>tp_as_mapping->mp_subscript</td></tr>
          <tr><td>__sequence__getitem__</td><td>tp_as_sequence->sq_item</td></tr>
          <tr><td>__mapping__setitem__</td><td>tp_as_mapping->mp_ass_subscript</td></tr>
          <tr><td>__sequence__setitem__</td><td>tp_as_sequence->sq_ass_item</td></tr>
        </table>

        <p>Operator methods can also be specified by their operators. The
        following are equivalent:</p>
        <table>
          <tr><td>&lt;</td><td>__lt__</td></tr>
          <tr><td>&lt;=</td><td>__le__</td></tr>
          <tr><td>==</td><td>__eq__</td></tr>
          <tr><td>!=</td><td>__ne__</td></tr>
          <tr><td>&gt;</td><td>__gt__</td></tr>
          <tr><td>&gt;=</td><td>__ge__</td></tr>
          <tr><td>()</td><td>__call__</td></tr>
          <tr><td>+</td><td>__add__</td></tr>
          <tr><td>+=</td><td>__iadd__</td></tr>
          <tr><td>-</td><td>__sub__</td></tr>
          <tr><td>-=</td><td>__isub__</td></tr>
          <tr><td>*</td><td>__mul__</td></tr>
          <tr><td>*=</td><td>__imul__</td></tr>
          <tr><td>**</td><td>__pow__</td></tr>
          <tr><td>**=</td><td>__ipow__</td></tr>
          <tr><td>/</td><td>__div__</td></tr>
          <tr><td>/=</td><td>__idiv__</td></tr>
          <tr><td>//</td><td>__floordiv__</td></tr>
          <tr><td>//=</td><td>__ifloordiv__</td></tr>
          <tr><td>&lt;&lt;</td><td>__lshift__</td></tr>
          <tr><td>&lt;&lt;=</td><td>__ilshift__</td></tr>
          <tr><td>&gt;&gt;</td><td>__rshift__</td></tr>
          <tr><td>&gt;&gt;=</td><td>__irshift__</td></tr>
          <tr><td>&amp;</td><td>__and__</td></tr>
          <tr><td>&amp;=</td><td>__iand__</td></tr>
          <tr><td>^</td><td>__xor__</td></tr>
          <tr><td>^</td><td>__ixor__</td></tr>
          <tr><td>|</td><td>__or__</td></tr>
          <tr><td>|=</td><td>__ior__</td></tr>
          <tr><td>~</td><td>__invert__</td></tr>
        </table>
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>

      <xsd:all minOccurs="0">
        <xsd:element ref="doc"/>
      </xsd:all>

      <xsd:attribute name="name" type="ident">
        <xsd:annotation>
          <xsd:documentation>
            The name of the function/method as will be seen in python. If not
            specified, the name will taken from the C++ function/method.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="func" type="symbol" use="required">
        <xsd:annotation>
          <xsd:documentation>
            <p>The C++ function/method that implements this.</p>

            <p>When specifying a method, whether the resulting Python method is
            static is determined by whether the C++ method is static. This can
            be overridden using the <var>static</var> attribute. A method may
            also be implemented using a C++ function, in which case the function
            must accept the class's type as the first argument, unless the
            <var>static</var> attribute is specified (to prevent mistakes,
            specifying a function that doesn't accept the class type as its
            first argument, without specifying <var>static</var>, is considered
            an error).</p>

            <p>The __rop__ methods will also accept C++ functions that accept
            the class type as the second argument.</p>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="overload" type="arglist">
        <xsd:annotation>
          <xsd:documentation>
            The list of arguments the C++ function/method takes. This is to
            select a specific function/method when the function/method is
            overloaded. The arguments are seperated by commas just like in the
            function/method. The types can be specified with or without
            typedefs, as long as the underlying types are the same as that of
            the function/method.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="return-semantic" type="retsemantictype">
        <xsd:annotation>
          <xsd:documentation>
            <p>Specifies how a pointer or reference return value is to be
            handled. If the function returns by value, this attribute is
            meaningless. The options are "default", "copy", "managedref" and
            "self". "default" is the same as ommitting this attribute. "copy"
            means the value will be dereferenced and copied. "managedref" means
            the returned Python object will keep a reference and a pointer to
            the class, in order to keep the class alive while the reference
            exists. "self" means ignore the return value and return what would
            be the "self" argument in Python.</p>

            <p>For __iop__ methods, the default is "self".</p>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="static" type="" default="false">
        <xsd:annotation>
          <xsd:documentation>
            For methods only, specifies whether the method will be static. This
            is determined automatically when <var>func</var> is a method.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="arity" type="">
        <xsd:annotation>
          <xsd:documentation>
            <p>Filters the overloaded functions/methods specified by
            <var>func</var> to ones that have this many arguments. This is so
            operators with different meaning but the same name (e.g. negation
            and subtraction), can be conveniently selected. Specifying both
            <var>arity</var> and <var>overload</var> is redundant.</p>
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>


  <xsd:element name="init">
    <xsd:complexType>
      <xsd:attribute name="overload" type="arglist"/>
    </xsd:complexType>
  </xsd:element>


  <xsd:element name="property">
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element ref="doc"/>
        <xsd:element name="get">
          <xsd:complexType>
            <xsd:attribute name="func" type="symbol" use="required"/>
            <xsd:attribute name="return-semantic" type="retsemantictype" default="default"/>
          </xsd:complexType>
        </xsd:element>
        <xsd:element name="set">
          <xsd:complexType>
            <xsd:attribute name="func" type="symbol" use="required"/>
            <xsd:attribute name="overload" type="arglist"/>
          </xsd:complexType>
        </xsd:element>
      </xsd:choice>

      <xsd:attribute name="name" type="ident" use="required"/>
      <xsd:attribute name="get" type="symbol"/>
      <xsd:attribute name="set" type="symbol"/>
    </xsd:complexType>
  </xsd:element>


  <xsd:element name="attr">
    <xsd:annotation>
      <xsd:documentation>
        Expose a member variable as a Python attribute.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:complexType>

      <xsd:attribute name="name" type="ident">
        <xsd:annotation>
          <xsd:documentation>
            The name of the member as will be seen in python. If not specified,
            the name will be taken from the C++ member.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="cmember" type="symbol" use="required">
        <xsd:annotation>
          <xsd:documentation>
            The member variable of the C++ class to expose.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="readonly" type="" default="false"/>

    </xsd:complexType>
  </xsd:element>


  <xsd:element name="class">
    <xsd:complexType>
      <xsd:choice maxOccurs="unbounded" minOccurs="0">
        <xsd:element ref="init"/>
        <xsd:element ref="def"/>
        <xsd:element ref="property"/>
        <xsd:element ref="attr"/>
        <xsd:element ref="doc"/>
      </xsd:choice>

      <xsd:attribute name="name" type="ident">
        <xsd:annotation>
          <xsd:documentation>
            The name of the class as will be seen in python. If not specified,
            the name will be taken from the C++ class, if the class name is a
            legal Python identifier, otherwise an arbitrary name is chosen.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>

      <xsd:attribute name="type" type="symbol" use="required">
        <xsd:annotation>
          <xsd:documentation>
            The C++ class to expose to python. The class may be an instantiation
            of a template, but cannot be the template itself (e.g. you can use
            std::vector&lt;int&gt;, but not std::vector).
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
    </xsd:complexType>
  </xsd:element>


  <xsd:element name="doc">
    <xsd:annotation>
      <xsd:documentation>
        A documentation string that will be exposed to Python.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleType>
      <xsd:restriction base="xsd:string">
        <xsd:whiteSpace value="preserve"/>
      </xsd:restriction>
    </xsd:simpleType>
  </xsd:element>
</xsd:schema>