#pragma once
#ifndef pyexpose_common_h
#define pyexpose_common_h

#include <Python.h>
#include <new>
#include <string>
#include <limits.h>


#ifdef __GNUC__
    #define LIKELY(X) __builtin_expect(static_cast<bool>(X),1)
    #define UNLIKELY(X) __builtin_expect(static_cast<bool>(X),0)
#else
    #define LIKELY(X) X
    #define UNLIKELY(X) X
#endif

#if defined(_WIN32) || defined(__CYGWIN__) || defined(__BEOS__)
    #define SHARED(RET) __declspec(dllexport) RET
#elif defined(__GNUC__) && __GNUC__ >= 4
    #define SHARED(RET) RET __attribute__((visibility("default")))
#else
    #define SHARED(RET) RET
#endif


#define PY_MEM_NEW_DELETE void *operator new(size_t s) {            \
        void *ptr = PyObject_Malloc(s);                             \
        if(!ptr) throw std::bad_alloc();                            \
        return ptr;                                                 \
    }                                                               \
                                                                    \
    void operator delete(void *ptr) {                               \
        PyObject_Free(ptr);                                         \
    }

#define PY_MEM_GC_NEW_DELETE void *operator new(size_t s) {         \
        void *ptr = _PyObject_GC_Malloc(s);                         \
        if(!ptr) throw std::bad_alloc();                            \
        return ptr;                                                 \
    }                                                               \
                                                                    \
    void operator delete(void *ptr) {                               \
        PyObject_GC_Del(ptr);                                       \
    }



#pragma GCC visibility push(hidden)

/* when thrown, indicates that a PyErr_X function was already called with the
   details of the exception. As such, it carries no information of its own. */
struct py_error_set {
    py_error_set() { assert(PyErr_Occurred()); }
    void clear() { PyErr_Clear(); }
};

enum storage_mode {UNINITIALIZED = 0,CONTAINS,MANAGEDREF,MANAGEDPTR,UNMANAGEDREF};


inline long py_to_long(PyObject *po) {
    long r = PyInt_AsLong(po);
    if(UNLIKELY(r == -1 && PyErr_Occurred())) throw py_error_set();
    return r;
}

// checks that min <= x <= max and raises an exception otherwise
long narrow(long x,long max,long min);

inline long PyToXInt(PyObject *po,long max,long min) {
    return narrow(py_to_long(po),max,min);
}

inline short py_to_short(PyObject *po) {
    return static_cast<short>(PyToXInt(po,SHRT_MAX,SHRT_MIN));
}

inline unsigned short py_to_ushort(PyObject *po) {
    return static_cast<unsigned short>(PyToXInt(po,USHRT_MAX,0));
}

inline unsigned long py_to_ulong(PyObject *po) {
    unsigned long r = PyLong_AsUnsignedLong(po);
    if(UNLIKELY(PyErr_Occurred())) throw py_error_set();
    return r;
}

/* Although the size of int is checked here, the code generated by expose.py
   assumes the size of int is the same as it was when gccxml was called, making
   this unsuitable to compile on a different platform than the one where gccxml
   was called. A future version may fix this. */
#if INT_MAX == LONG_MAX
    inline int py_to_int(PyObject *po) { return py_to_long(po); }
    inline unsigned int py_to_uint(PyObject *po) { return py_to_ulong(po); }
    inline PyObject *uint_to_py(unsigned int x) { return PyLong_FromUnsignedLong(x); }
#else
    inline PyObject *uint_to_py(unsigned int x) { return PyInt_FromLong(x); }

    #if INT_MAX == SHRT_MAX
        inline int py_to_int(PyObject *po) { return py_to_short(po); }
        inline unsigned int py_to_uint(PyObject *po) { return py_to_ushort(po); }

    #else
        inline int py_to_int(PyObject *po) {
            return static_cast<int>(PyToXInt(po,INT_MAX,INT_MIN));
        }

        inline unsigned int py_to_uint(PyObject *po) {
            return static_cast<unsigned int>(PyToXInt(po,UINT_MAX,0));
        }
    #endif
#endif

#ifdef HAVE_LONG_LONG
    inline long long py_to_longlong(PyObject *po) {
        long long r = PyLong_AsLongLong(po);
        if(UNLIKELY(PyErr_Occurred())) throw py_error_set();
        return r;
    }

    inline unsigned long long py_to_ulonglong(PyObject *po) {
        unsigned long long r = PyLong_AsUnsignedLongLong(po);
        if(UNLIKELY(PyErr_Occurred())) throw py_error_set();
        return r;
    }
#endif

inline double py_to_double(PyObject *po) {
    double r = PyFloat_AsDouble(po);
    if(UNLIKELY(PyErr_Occurred())) throw py_error_set();
    return r;
}

inline PyObject *string_to_py(const std::string &s) {
    return PyString_FromStringAndSize(s.c_str(),s.size());
}

inline PyObject *bool_to_py(bool x) {
    PyObject *r = x ? Py_True : Py_False;
    Py_INCREF(r);
    return r;
}

inline unsigned char py_ssize_t_to_uchar(Py_ssize_t x) {
    return static_cast<unsigned char>(narrow(x,UCHAR_MAX,0));
}

inline signed char py_ssize_t_to_schar(Py_ssize_t x) {
    return static_cast<signed char>(narrow(x,SCHAR_MAX,SCHAR_MIN));
}

#if CHAR_MIN == 0
    inline unsigned char py_ssize_t_to_char(Py_ssize_t x) { return py_ssize_t_to_uchar(x); }
#else
    inline signed char py_ssize_t_to_char(Py_ssize_t x) { return py_ssize_t_to_schar(x); }
#endif

inline unsigned short py_ssize_t_to_ushort(Py_ssize_t x) {
    return static_cast<unsigned short>(narrow(x,USHRT_MAX,0));
}

inline short py_ssize_t_to_sshort(Py_ssize_t x) {
    return static_cast<short>(narrow(x,SHRT_MAX,SHRT_MIN));
}

#if (PY_SIZE_MAX>>1) > INT_MAX
    inline unsigned int py_ssize_t_to_uint(Py_ssize_t x) {
        return static_cast<unsigned int>(narrow(x,UINT_MAX,0));
    }

    inline int py_ssize_t_to_sint(Py_ssize_t x) {
        return static_cast<int>(narrow(x,INT_MAX,INT_MIN));
    }
#else
    inline int py_ssize_t_to_sint(Py_ssize_t x) { return x; }

    inline unsigned int py_ssize_t_to_uint(Py_ssize_t x) {
        return static_cast<unsigned int>(narrow(x,INT_MAX,0));
    }
#endif

inline unsigned long py_ssize_t_to_ulong(Py_ssize_t x) {
    return static_cast<unsigned long>(narrow(x,LONG_MAX,0));
}


#ifdef PYEXPOSE_TEMPLATE_HELPERS

template<typename T> inline PyObject *to_pyobject(T x) {
    int dont_instantiate[sizeof(T) < 0 ? 1 : -1];
    return NULL;
}

template<> inline PyObject *to_pyobject<short>(short x) {
    return PyInt_FromLong(x);
}

template<> inline PyObject *to_pyobject<unsigned short>(unsigned short x) {
    return PyInt_FromLong(x);
}

template<> inline PyObject *to_pyobject<long>(long x) {
    return PyInt_FromLong(x);
}

template<> inline PyObject *to_pyobject<unsigned long>(unsigned long x) {
    return PyLong_FromUnsignedLong(x);
}

#ifdef HAVE_LONG_LONG
template<> inline PyObject *to_pyobject<long long>(long long x) {
    return PyLong_FromLongLong(x);
}

template<> inline PyObject *to_pyobject<unsigned long long>(unsigned long long x) {
    return PyLong_FromUnsignedLongLong(x);
}
#endif

#if INT_MAX != LONG_MAX && INT_MAX != SHORT_MAX
template<> inline PyObject *to_pyobject<int>(int x) {
    return PyInt_FromLong(x);
}

template<> inline PyObject *to_pyobject<unsigned int>(unsigned int x) {
    return PyInt_FromLong(x);
}
#endif

template<> inline PyObject *to_pyobject<bool>(bool x) {
    return bool_to_py(x);
}

template<> inline PyObject *to_pyobject<float>(float x) {
    return PyFloat_FromDouble(x);
}

template<> inline PyObject *to_pyobject<double>(double x) {
    return PyFloat_FromDouble(x);
}

template<> inline PyObject *to_pyobject<const char*>(const char *x) {
    return PyString_FromString(x);
}



template<typename T> inline T from_pyobject(PyObject *o) {
    int dont_instantiate[sizeof(T) < 0 ? 1 : -1];
    return T();
}

template<> inline short from_pyobject<short>(PyObject *o) {
    return py_to_short(o);
}

template<> inline unsigned short from_pyobject<unsigned short>(PyObject *o) {
    return py_to_ushort(o);
}

template<> inline long from_pyobject<long>(PyObject *o) {
    return py_to_long(o);
}

template<> inline unsigned long from_pyobject<unsigned long>(PyObject *o) {
    return py_to_ulong(o);
}

#ifdef HAVE_LONG_LONG
template<> inline long long from_pyobject<long long>(PyObject *o) {
    return py_to_longlong(o);
}

template<> inline unsigned long long from_pyobject<unsigned long long>(PyObject *o) {
    return py_to_ulonglong(o);
}
#endif

#if INT_MAX != LONG_MAX && INT_MAX != SHORT_MAX
template<> inline int from_pyobject<int>(PyObject *o) {
    return static_cast<int>(from_pyobject<long>(o));
}

template<> inline unsigned int from_pyobject<unsigned int>(PyObject *o) {
    return static_cast<unsigned int>(from_pyobject<long>(o));
}
#endif

template<> inline bool from_pyobject<bool>(PyObject *o) {
    return static_cast<bool>(PyObject_IsTrue(o));
}

template<> inline float from_pyobject<float>(PyObject *o) {
    return static_cast<float>(py_to_double(o));
}

template<> inline double from_pyobject<double>(PyObject *o) {
    return py_to_double(o);
}

template<> inline const char *from_pyobject<const char*>(PyObject *o) {
    return PyString_AsString(o);
}



// The following templates are specialized for each exposed class

template<typename T> inline PyTypeObject *get_type() {
    int dont_instantiate[sizeof(T) < 0 ? 1 : -1];
    return 0;
}

template<typename T> inline T &get_base(PyObject *o) {
    int dont_instantiate[sizeof(T) < 0 ? 1 : -1];
}

template<typename T> struct wrapped_type {
    typedef void type;
};

/* When invariable_storage<T>::value is 1, the location of T inside of its
   wrapped type will always be the same, thus an instance of T can be accessed
   from a PyObject pointer using
   reinterpret_cast<wrapped_type<T>::type*>(pointer)->base. However, the
   instance will not necessarily be initialized. Call get_base at least once to
   ensure that it is (once initialized, it can never be uninitialized). */
template<typename T> struct invariable_storage {
    enum {value = 0};
};

#endif


#pragma GCC visibility pop

#endif
